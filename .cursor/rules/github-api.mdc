---
description: "GitHub API integration patterns and dual-API architecture"
---

# GitHub API Integration

## Dual API Architecture

This project uses **both** GitHub REST (v3) and GraphQL (v4) APIs.

### When to Use REST API (v3)

- Implemented in [github_v3.go](mdc:github_v3.go)
- Repository settings and configuration
- Team permissions management
- Branch protection rules
- Available operations via `GitHubV3Client` interface

### When to Use GraphQL API (v4)

- Implemented in [github_v4.go](mdc:github_v4.go) and [v4api/client.go](mdc:v4api/client.go)
- Repository archiving operations
- Label synchronization
- Bulk operations and complex queries
- Generated client code in [v4api/generated.go](mdc:v4api/generated.go)

## GraphQL Code Generation

- Schema: [schema.graphql](mdc:schema.graphql)
- Queries: [genqlient.graphql](mdc:genqlient.graphql)
- Config: [genqlient.yaml](mdc:genqlient.yaml)
- Generation commands:
  - `task gql:download-schema` - Update GitHub's GraphQL schema
  - `task gql:generate-client` - Regenerate client code
- Uses `github.com/Khan/genqlient` for code generation

## Client Initialization

- REST client: `github.com/google/go-github/v66`
- GraphQL client: `github.com/shurcooL/githubv4`
- **Always** require OAuth token via `GITHUB_TOKEN` environment variable
- Return errors instead of panicking in constructors

## Error Handling

- Guard against nil HTTP responses in v3 client
- Check error ordering in function returns
- Wrap errors with context about the operation
- Log HTTP responses only in debug mode (sensitive data)

## Rate Limiting

- Check rate limits with `ratelimit` command
- Implement backoff strategies for bulk operations
- GraphQL has different rate limiting than REST

## Best Practices

- Prefer GraphQL for operations that need multiple resources
- Use REST for simple CRUD operations
- Cache repository data when possible
- Test with mocks: [mocks/github_v3_mocks.go](mdc:mocks/github_v3_mocks.go) and [mocks/github_v4_mocks.go](mdc:mocks/github_v4_mocks.go)
